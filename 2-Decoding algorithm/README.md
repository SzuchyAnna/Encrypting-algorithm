The file: Feladatleírás.txt is the original description of this excercise in Hungarian. What the code does can be found in this README in detail.


First we find the main function called decoder. If one runs it, it will automatically use the other functions below.
What this function does is that, if given two encrypted messages that were encrypted with the same key by using the method described in the encrypting algorithm,
and receiving a word of one of the messages, can guess the key and the two messages based on a wordset titled WORDS.TXT.


WARNING! This code can only run if the known word is given without any spacing or additional characterset at the end of it. Also it works only with messages of the same length.
Can be used only with English alphabetic messages that might have space in it.



decoder(word, encrypted_message_word_s, encrypted_message_other)

first updates the first message (message_1) with the given word and adding a space. Then it generates the first couple of characters of the key in a 
list using piece_teller (see below) based on what we know of the first message (message_1). 

The code works with a variable called 'piece'. It is a list of characters generated by piece_teller and, though, outside of decoding_cycle (see below) it only appears 
once, the general idea is that it always containes the next piece of one of the messages (once the firts, then the second message, then first again, 
etc.) that helps us guess the next word of the message.

Since the next piece of the next word might mean multiple words, the function word_guesser (see below) will generate a list of potential words that might
be the next ones (word_list). 

At this point decoder appends what we already know (piece) of the second message, the one that we didn't know a word of before
(message_2) but only to be able to enter the inner, recursive cycle (decoding_cycle) without a fail. Finally it uses decoding_cycle to loop through all
the remaining steps that are almost identical to these ones but needed some alteration, and prints the key, and the two messages out.



decoding_cycle(piece, word_list, message_lesser_known, encrypted_message_more, encrypted_message_less)

The function gets the piece that we know of the nex word (piece) of the next guessable message (message_lesser_known), the list of words that might be 
the next word of the above-mentioned message (word_list), what we know of the lesser known message yet, but not the other one because it is easier to just 
regenerate the whole message again, and the 2 encrypted messages (encrypted_message_less and encrypted_message_more, referring to which message they belong to).

It iterates through the list of words (word_list) and does the following:

Updates the lesser known message with the guessed word.

Generates a key based on the new message with piece_teller (see below)

Rewrites the more known message based on the new key also with piece_teller (see below)

Gets the new piece of word that now belongs to the other message. In case the newly discovered keypart revealed more than one word like 'a blo' for 'a blouse',
this line works with the last part after the last space.

Generates a new word list, yet again of the new piece with word_guesser (see below).

And finally enters an if statement that returns the newly generated key and the 2 messages if the whole messages are uncovered (if we got the length of the key
the same as the encrypted messages'), and calles itself upon the new variables if not.



word_guesser(word_piece)

Opens words.txt as to search for any words in it that start with the given piece of a word (word_piece). It returns a list with every word that fits this
criteria.



piece_teller(m_k, encrypted_message)

piece_teller receives a message or a key part (therefore m_k) and an encrypted message (encrypted_message) and calculates the key or the message part
belonging to the given message or key part based on the encrypted message and the general encrypting method used and described in the first excercise 
(Encrypting algorithm) using num_gen (see below). It returns a list with characters in it.



num_gen(text)

It generates a list of numbers modulo 27 of letters, where a is 0, b is 1, ... z is 25 according to english lowercase letters, and space equals to 26.
It can not work with uppercase or non-English alphabetic letters or special characters, numbers. 
